# Using Statement
ITSE 1430
:toc:

The link:try-finally.adoc[Try-Finally] block can be used to clean up resources, such as files or database connections, even in the case of exceptions but the syntax is a little complex.

.Using a Try-Finally Block
[source,csharp]
----
Stream stream = null;
try
{
   stream = File.OpenRead("data.dat");
} finally
{
   stream?.Close();
};
----

There are several problems with this syntax.

- The resource to be cleaned up must be hoisted outside the block. This can potentially introduce scoping issues.
- Clean up code must handle the case where the resource was never initialized.
- Within the same method variable names must be unique to avoid conflicts.

The https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/using-statement[using statement] is available in C# to address this concern. 

NOTE: Do not confuse this with the `using` directive that generally appears at the top of a file and imports namespaces.*

## Using Statement

The syntax of the `using` statement is simplified over a traditional `try-finally` block.

.Using Statement Syntax
[source,csharp]
----
using (expression)
{
   //Code
}
----

The code inside the `using` block is contained in a `try` block. When the block ends, either successfully or with an exception, then the resource defined by `expression` is cleaned up automatically. The `using` statement is expanded into the equivalent `try-finally` code.

.Try-Finally Equivalent
[source,csharp]
----
var resource = expression;
try
{
   //Code
} finally
{   
   //Clean up resource
}
----

## IDisposable Interface

Since the compiler has to generate the cleanup code it needs to know how to clean up the resource. The https://docs.microsoft.com/en-us/dotnet/api/system.idisposable[IDisposable  interface] provides this information. This interface contains a single method called https://docs.microsoft.com/en-us/dotnet/api/system.idisposable.dispose[Dispose] that cleans up the resource. This is generally referred to as a disposable object (hereafter called a resource).

.Try-Finally with IDisposable
[source,csharp]
----
IDisposable resource = expression;
try
{
   //Code
} finally
{   
   resource?.Dispose();
}
----

NOTE: All types in .NET that need to be cleaned up implement the `IDisposable` interface. When writing types that require clean up ensure you implement this interface as well.

When combined with a `using` statement the syntax is much cleaner than a `try-finally`. 

.Using Statement
[source,csharp]
----
using (var file = File.OpenRead("data.dat"))
{
   //Use file
};
----

It is common to declare the resource in the `using` statement. This helps keep the scope of the variable limited. Additionally multiple `using` statements can be used in the same method without having to use old variable names.

## Dispose vs Close

In some cases a resource may expose an alternative method besides `Dispose` to clean it up. This is often done when the resource has a logical name for clean up. https://docs.microsoft.com/en-us/dotnet/api/system.io.stream[Stream] is a good example. It exposes a https://docs.microsoft.com/en-us/dotnet/api/system.io.stream.close[Close] method. 

In these cases either method may be called. Both will dispose of the resource. The preference is to use the `using` statement so cleaning up the resource is not necessary. In the rare cases where you would clean it up directly prefer the type-specific method for readability.

## Object Lifetime

When dealing with resources it is critical that the lifetime of the resource be managed properly. There are several scenarios that can occur when dealing with these types of objects.

### Limited Scope 

The most common case is that a resource is only needed for a short period of time, a single method. This is where the `using` statement is used. In the earlier example the file was opened (and closed) inside the same method. This is the most common case for resources and should be preferred whenever possible.

.Limited Scope Lifetime
[source, csharp]
----
using (reader = new StreamReader())
{   
}
----

### Resource Returning Methods

In the earlier example `OpenRead` returned the stream resource. This is common and should be treated as being the same as creating the resource directly. The calling method is responsible for cleaning up the resource. Again, the `using` statement is appropriate here.

.Resource Returing Method Lifetime
[source, csharp]
----
using (var reader = File.OpenRead("data.dat"))
{   
}
----

### Parameter Resource

Another common scenario is receiving a resource as a parameter. Called methods have no way of knowing how an argument is being used outside of the method and therefore should treat any resource as being "on loan". In other words a method should not clean up a resource that is passed to it as a parameter unless the method is explicitly related to cleaning up the resource. Instead the method should simply use the resource and not bother cleaning it up, even in the case of an exception.

.Parameter Resource Lifetime
[source,csharp]
----
int ReadInt32 ( Stream stream )
{
   //Read int
}
----

This is necessary because in many cases the calling code has already wrapped the resource in a `using` statement. It would considered to be a bug if a method cleaned up a resource just because it was passed as a parameter.

.Calling ReadInt32
[source,csharp]
----
using (var stream = File.OpenRead("data.dat"))
{
   var id = ReadInt32(stream);
}
----

### Resource Acquisition is Initialization

Things get more interesting when receiving a resource as a parameter to a constructor. Constructors involve the creation of an object. Any paramemters passed to a constructor are assumed to be owned by the constructor. Therefore any resource passed to the constructor becomes the responsibility of the new instance. This is known as https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization[RAII], resource acquisition is initialization, in programming. Acquiring a resource, during initialization, makes the acquiring object responsibel for its lifetime. 

In this scenario the lifetime of the resource is now tied to the lifetime of the new instance. https://docs.microsoft.com/en-us/dotnet/api/system.io.streamreader[StreamReader] is a great example of this. It receives a https://docs.microsoft.com/en-us/dotnet/api/system.io.stream[Stream] as a constructor parameter and it is responsible for the stream until it is cleaned up.

.RAII
[source, csharp]
----
using (var stream = File.OpenRead("data.dat"))
using (var reader = new StreamReader(stream))
{
   //Stream is cleaned up by reader  
}
----

In this particular case the `Stream` is still wrapped in a `using` statement because an exception could occur after the stream is created but before the `StreamReader` is, albeit rare. However when the stream is eventually cleaned up it will have already been cleaned up by the reader.

CAUTION: If you create a type that receives an `IDisposable` object as a constructor parameter then you must follow the rules of RAII as well. This generally means you need to implement `IDisposable` and ensure it cleans up any constructor parameter you received.

## Cleaning Up Resources Multiple Times

Disposable objects are responsible for ensuring they clean themselves up properly. After being disposed it is generally an error to try to use the object further. In most cases the https://docs.microsoft.com/en-us/dotnet/api/system.objectdisposedexception[ObjectDisposedException] will be thrown when trying to use an object after it is disposed. It is up to each type to determine which members, if any, care about this. In some cases an object may be reusable after it has been disposed but this is rare because of how disposal is implemented in the runtime.

In all cases disposing of an object that is already disposed is harmless. Types that implement `IDisposable` allow this method to be called more than once. They simply do nothing when called again. This unfortunately leads to poorly written code like this.

.Disposing Multiple Times
[source,csharp]
----
using (var stream = File.OpenRead("data.dat"))
{   
   stream.Close();    //Clean up 1, closes stream
   stream.Dispose();  //Clean up 2, does nothing
   stream = null;     //Does nothing since variable is about to go out of scope
}  //Clean up 3, finally block executes
----

While this is harmless in most cases it is redundant. Code should not worry about cleanup when using the `using` statement.

NOTE: Some types that implement `IDisposable` also provide a `IsDisposed` property to indicate they are disposed. In this case code can rely on this property but it is not universally implemented.

## See Also

https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/try-finally[C# Try-Finally Block] +
https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/using-statement[C# Using Statement] +
https://docs.microsoft.com/en-us/dotnet/api/system.idisposable[IDisposable Interface] +
link:try-finally.adoc[Try-Finally]
